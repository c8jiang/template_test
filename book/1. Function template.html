<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><style type="text/css"><!--
  .s1 { font-family: sans-serif; font-weight: normal; font-size: 20pt; }
 .s2 { color: #808080; font-family: sans-serif; font-weight: normal; font-size: 10pt; }
 .s3 { color: #808080; font-family: serif; font-weight: normal; font-size: 10pt; }
 .s4 { font-family: sans-serif; font-weight: normal; font-size: 11pt; }
 .p, p { font-family: serif; font-weight: normal; font-size: 11pt; }
 a { color: #00F; font-family: sans-serif; font-weight: normal; text-decoration: underline; font-size: 11pt; }
 .s5 { font-family: serif; font-weight: normal; font-size: 10pt; }
  -->
</style></head><body><p class="s1">Function template</p><p class="s2">2018<span class="s3">年</span>4<span class="s3">月</span>20<span class="s3">日      </span>14:21</p><p class="s4">1.   Template Argument Deduction</p><p class="s4">type conversions during type deduction <span class="p">注意：自动类型转换在类型推导时会被限制</span></p><p class="s4">•   <span class="p">当声明使用传引用调参时，类型推导甚至不会应用细小的转换。</span></p><p class="s4">•   <span class="p">当声明使用传值调参时，只有细小的转换——退化会被支持：忽略限定词</span></p><p class="s4">cosnt,volatile<span class="p">，引用转化为引用类型，数组或函数转化为相应的指针类型。</span></p><p class="s4">2.   Multiple Template Parameter</p><p class="s4">c++<span class="p">提供了不同的方法来处理返回类型的问题：</span></p><p class="s4">•   <span class="p">引入第三个模板参数用作返回类型</span></p><p class="s4">•   <span class="p">让编译器找出返回类型</span></p><p class="s4">•   <span class="p">将返回类型声明为两个参数类型的</span>&quot;common type&quot;</p><p>显示指定模板参数</p><p class="s4">3.   Default Template Argument</p><p>你也可以定义模板参数的默认值，它可以和任意模板一起使用（<span class="s4">c++11</span>）。</p><p class="s4">4.   Overloading Function Templates</p><p class="s4">c++<span class="p">编译通过一些额外的信息来决定调用重载函数中的一个，几乎都是通过调用参数的类</span></p><p>型信息来决定。<br/><a href="http://zh.cppreference.com/w/cpp/language/overload_resolution">http://zh.cppreference.com/w/cpp/language/overload_resolution</a></p><p class="s4">5.   Pass by Value or by Reference?</p><p>你可能会想，为什么声明函数参数一般使用传值的方式而不是传引用。一般来说，对于<br/>那些不是简单类型（基本类型或<span class="s4">std::string_view</span>）的类型推荐传引用方式，因为传值会产 生不必要的拷贝。<br/>但是，由于以下的原因，一般来说传值更好：</p><p class="s4">•   <span class="p">语法简单</span></p><p class="s4">•   <span class="p">编译器优化更好</span></p><p class="s4">•   <span class="p">移动语义经常降低拷贝开销</span></p><p class="s4">•   <span class="p">有些时候根本没有拷贝或移动 另外，对于模板，还有这些方面的作用：</span></p><p class="s4">•   <span class="p">一个模板可能会用于简单类型和复杂类型这两者，所以如果选择适合复杂类型的方式， 也许对于简单类型会适得其反。</span></p><p class="s4">•   <span class="p">作为函数调用者，你仍然可以决定使用引用传参，使用</span>std::ref(), std::cref()<span class="p">。</span></p><p class="s5">分区 C^M^M语言 的第 1 页</p><p class="s4">•   <span class="p">尽管传递字符串或数组总是会变成一个问题，但是使用引用的方式传递它们经常被认为</span></p><p>会变成一个更大的问题。</p><p class="s4">6.   <span class="p">小结</span></p><p class="s4">•   <span class="p">模板函数为不同的模板实参定义了一个函数家族</span></p><p class="s4">•   <span class="p">当你传递模板实参时，函数模板会推导模板参数来实例化相应的参数类型</span></p><p class="s4">•   <span class="p">你可以显示指定模板参数</span></p><p class="s4">•   <span class="p">你可以定义模板参数的默认值</span></p><p class="s4">•   <span class="p">你可以重载函数模板</span></p><p class="s4">•   <span class="p">当你用其他函数模板重载函数模板时，你应当确保任何调用有唯一匹配</span></p><p class="s4">•   <span class="p">当你重载函数模板时，将你的改变限制在显示指定模板参数</span></p><p class="s4">•   <span class="p">确保在你调用函数模板之前，编译器能看到所有重载版本</span></p><p class="s5">分区 C^M^M语言 的第 2 页</p></body></html>
